#![allow(clippy::unused_unit)]
use polars::prelude::*;
use pyo3_polars::derive::polars_expr;
use std::fmt::Write;
use std::borrow::Cow;
use polars_arrow::array::{Array, MutablePlString};

fn it_slices(val: &str) -> &str {
    &val[1..]
}


#[polars_expr(output_type=String)]
fn it_slices_apply_values_borrowed(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_values(|val| {
        let res = Cow::Borrowed(it_slices(val));
        res
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn it_slices_apply_to_buffer(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_to_buffer(|val, buf| {
        write!(buf, "{}", it_slices(val)).unwrap();
    });
    Ok(out.into_series())
}

fn apply_to_buffer_with_builder<'a, T, F>(ca: &'a ChunkedArray<T>, mut f: F) -> StringChunked
where
    T: PolarsDataType,
    F: FnMut(T::Physical<'a>, &mut String),
{
    let mut buf = String::new();
    let chunks = ca
        .downcast_iter()
        .map(|arr| {
            let mut mutarr = MutablePlString::with_capacity(arr.len());
            arr.iter().for_each(|opt| {
                match opt {
                    None => mutarr.push_null(),
                    Some(v) => {
                        buf.clear();
                        f(v, &mut buf);
                        mutarr.push_value(&buf)
                    },
                }
            });
            mutarr.freeze()
        })
        .collect::<Vec<_>>();
    ChunkedArray::from_chunk_iter(ca.name(), chunks)
}

#[polars_expr(output_type=String)]
fn it_slices_apply_to_buffer_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = apply_to_buffer_with_builder(ca, |val, buf| {
        write!(buf, "{}", it_slices(val)).unwrap();
    });
    Ok(out.into_series())
}
