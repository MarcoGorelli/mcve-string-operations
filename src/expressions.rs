#![allow(clippy::unused_unit)]
use polars::prelude::*;
use pyo3_polars::derive::polars_expr;
use std::fmt::Write;
use std::borrow::Cow;
use polars_arrow::array::{Array, MutablePlString};

#[polars_expr(output_type=String)]
fn pig_latinnify_allocating(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_values(|val| {
        if let Some(first_char) = val.chars().next() {
            Cow::Owned(format!("{}{}ay", &val[1..], first_char))
        } else {
            Cow::Borrowed(val)
        }
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn pig_latinnify_amortized(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_to_buffer(|val, buf| {
        if let Some(first_char) = val.chars().next() {
            write!(buf, "{}{}ay", &val[1..], first_char).unwrap()
        }
    });
    Ok(out.into_series())
}

fn apply_to_buffer_with_builder<'a, T, F>(ca: &'a ChunkedArray<T>, mut f: F) -> StringChunked
where
    T: PolarsDataType,
    F: FnMut(T::Physical<'a>, &mut String),
{
    let mut buf = String::new();
    let chunks = ca
        .downcast_iter()
        .map(|arr| {
            let mut mutarr = MutablePlString::with_capacity(arr.len());
            arr.iter().for_each(|opt| {
                match opt {
                    None => mutarr.push_null(),
                    Some(v) => {
                        buf.clear();
                        f(v, &mut buf);
                        mutarr.push_value(&buf)
                    },
                }
            });
            mutarr.freeze()
        })
        .collect::<Vec<_>>();
    ChunkedArray::from_chunk_iter(ca.name(), chunks)
}

#[polars_expr(output_type=String)]
fn pig_latinnify_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = apply_to_buffer_with_builder(ca, |val, buf| {
        if let Some(first_char) = val.chars().next() {
            write!(buf, "{}{}ay", &val[1..], first_char).unwrap()
        }
    });
    Ok(out.into_series())
}
