#![allow(clippy::unused_unit)]
use polars::prelude::*;
use pyo3_polars::derive::polars_expr;
use std::fmt::Write;
use std::borrow::Cow;
use crate::utils::apply_to_buffer_with_builder;

#[polars_expr(output_type=String)]
fn pig_latinnify_allocating(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_values(|val| {
        if let Some(first_char) = val.chars().next() {
            Cow::Owned(format!("{}{}ay", &val[1..], first_char))
        } else {
            Cow::Borrowed(val)
        }
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn pig_latinnify_amortized(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_to_buffer(|val, buf| {
        if let Some(first_char) = val.chars().next() {
            write!(buf, "{}{}ay", &val[1..], first_char).unwrap()
        }
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn pig_latinnify_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = apply_to_buffer_with_builder(ca, |val, buf| {
        if let Some(first_char) = val.chars().next() {
            write!(buf, "{}{}ay", &val[1..], first_char).unwrap()
        }
    });
    Ok(out.into_series())
}

/// numeric

#[polars_expr(output_type=String)]
fn numeric_op_allocating(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.i64()?;
    let out: StringChunked = ca.apply_values_generic(|val| {
        Cow::Owned(format!("{} for the win", val))
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn numeric_op_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.i64()?;
    let out: StringChunked = apply_to_buffer_with_builder(ca, |val, buf| {
        write!(buf, "{} for the win", val).unwrap()
    });
    Ok(out.into_series())
}
