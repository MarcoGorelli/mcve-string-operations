#![allow(clippy::unused_unit)]
use crate::utils::apply_to_buffer_with_builder;
use polars::prelude::*;
use pyo3_polars::derive::polars_expr;
use std::borrow::Cow;
use std::fmt::Write;
use polars::prelude::arity::unary_elementwise_values;

#[polars_expr(output_type=String)]
fn pig_latinnify_allocating(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_values(|val| {
        if let Some(first_char) = val.chars().next() {
            Cow::Owned(format!("{}{}ay", &val[1..], first_char))
        } else {
            Cow::Borrowed(val)
        }
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn pig_latinnify_amortized(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_to_buffer(|val, buf| {
        if let Some(first_char) = val.chars().next() {
            write!(buf, "{}{}ay", &val[1..], first_char).unwrap()
        }
    });
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn pig_latinnify_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = apply_to_buffer_with_builder(ca, |val, buf| {
        if let Some(first_char) = val.chars().next() {
            write!(buf, "{}{}ay", &val[1..], first_char).unwrap()
        }
    });
    Ok(out.into_series())
}

/// numeric

#[polars_expr(output_type=String)]
fn numeric_op_allocating(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.i64()?;
    let out: StringChunked =
        ca.apply_values_generic(|val| Cow::Owned(format!("{} for the win", val)));
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn numeric_op_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.i64()?;
    let out: StringChunked =
        apply_to_buffer_with_builder(ca, |val, buf| write!(buf, "{} for the win", val).unwrap());
    Ok(out.into_series())
}


#[polars_expr(output_type=String)]
fn slicing_op_with_builder(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked =
        apply_to_buffer_with_builder(ca, |val, buf| write!(buf, "{}", &val[0..5]).unwrap());
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn slicing_op_with_unary(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked =
        unary_elementwise_values(ca, |val| &val[..5]);
    Ok(out.into_series())
}

#[polars_expr(output_type=String)]
fn slicing_op_apply_values(inputs: &[Series]) -> PolarsResult<Series> {
    let s = &inputs[0];
    let ca = s.str()?;
    let out: StringChunked = ca.apply_values(|val| Cow::Borrowed(&val[..5]));
    Ok(out.into_series())
}


